<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>User Namespaces | posts</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-64244584-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">posts</a></li>
      
      <li><a href="/about/">about</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">User Namespaces</span></h1>

<h2 class="date">2019/02/20</h2>
</div>

<main>
<p>Ian Coldwater recently had a great thread on <a href="https://twitter.com/IanColdwater/status/1097036373465407489">bridging the gap between the security and container worlds</a>. A lot of those answers wont fit in a tweet, so here’s my attempt for a more in-depth response.</p>
<h2 id="namespaces-for-everyone">Namespaces for everyone</h2>
<p>User namespaces are a way to create unique views of user and group IDs. Unlike <a href="../containers-from-scratch/">other namespaces</a>, they can be created by non-root users and are primarily used by unprivileged processes to access capabilities normally reserved for root.</p>
<p>The <code>unshare</code> tool can be used to create a user namespace and act as root:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ whoami
ericchiang
$ unshare --map-root-user
<span style="color:#75715e"># whoami</span>
root
</code></pre></div><p>Under the hood, <code>unshare</code> is calling <a href="https://linux.die.net/man/2/unshare"><code>unshare(2)</code></a> and <code>fork(2)</code>, modifying the UID and GID mappings files under <code>/proc</code> , then exec’ing a shell:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ unshare --map-root-user
<span style="color:#75715e"># cat /proc/self/uid_map</span>
         <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">1000</span>          <span style="color:#ae81ff">1</span>
<span style="color:#75715e"># cat /proc/self/gid_map</span>
         <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">1000</span>          <span style="color:#ae81ff">1</span>
</code></pre></div><p>The map files are formatted as follows. In the case above, <code>0</code> (root) for the target ID, <code>1000</code> (my PID/GID) for the source ID, and <code>1</code> to only map a single UID and GID:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#f92672">[</span>target ID<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>source ID<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>ID range<span style="color:#f92672">]</span>
</code></pre></div><p>Within a user namespace, a process can run commands as if it was root. For example, an unprivileged user can call <code>chroot</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ <span style="color:#75715e"># create a root file system</span>
$ mkdir rootfs
$ sudo debootstrap stable rootfs http://deb.debian.org/debian/
…
$ unshare --map-root-user chroot rootfs <span style="color:#75715e"># run without sudo</span>
<span style="color:#75715e"># ls /</span>
bin  boot  dev  etc  home  lib  lib64  media  mnt
opt  proc  root  run  sbin  srv  sys  tmp  usr  var
</code></pre></div><p>Or setup other namespaces and mount filesystems:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ <span style="color:#75715e"># create a user, mount, and PID namespace</span>
$ unshare --map-root-user --mount --pid --fork
<span style="color:#75715e"># mount -t proc proc $PWD/rootfs/proc</span>
<span style="color:#75715e"># chroot rootfs</span>
<span style="color:#75715e"># ps</span>
    PID TTY          TIME CMD
      <span style="color:#ae81ff">1</span> ?        00:00:00 bash
      <span style="color:#ae81ff">3</span> ?        00:00:00 ps
</code></pre></div><p>But are we root? We certainly have a lot of capabilities:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ unshare --map-root-user capsh --print
Current: <span style="color:#f92672">=</span> cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read+ep
Bounding set <span style="color:#f92672">=</span>cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read
Securebits: 00/0x0/1<span style="color:#960050;background-color:#1e0010">&#39;</span>b0
 secure-noroot: no <span style="color:#f92672">(</span>unlocked<span style="color:#f92672">)</span>
 secure-no-suid-fixup: no <span style="color:#f92672">(</span>unlocked<span style="color:#f92672">)</span>
 secure-keep-caps: no <span style="color:#f92672">(</span>unlocked<span style="color:#f92672">)</span>
uid<span style="color:#f92672">=</span>0<span style="color:#f92672">(</span>root<span style="color:#f92672">)</span>
gid<span style="color:#f92672">=</span>0<span style="color:#f92672">(</span>root<span style="color:#f92672">)</span>
groups<span style="color:#f92672">=</span>65534<span style="color:#f92672">(</span>nogroup<span style="color:#f92672">)</span>,65534<span style="color:#f92672">(</span>nogroup<span style="color:#f92672">)</span>,65534<span style="color:#f92672">(</span>nogroup<span style="color:#f92672">)</span>,0<span style="color:#f92672">(</span>root<span style="color:#f92672">)</span>
</code></pre></div><p>The truth is, once the process attempts to interact with a resource outside of the namespace, “real root” restrictions apply. For example, the process can’t listen on a privileged port:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ unshare --map-root-user nc -l -p <span style="color:#ae81ff">80</span>
Can<span style="color:#960050;background-color:#1e0010">&#39;</span>t grab 0.0.0.0:80 with bind : Permission denied
</code></pre></div><p>Or override host file permissions:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ unshare --map-root-user cat /etc/shadow
cat: /etc/shadow: Permission denied
</code></pre></div><p>Ultimately, the process is only root in the namespace and host restrictions still apply as if it was running as a normal user.</p>
<h2 id="use-in-practice">Use in practice</h2>
<p>In practice, user namespaces are largely used for unprivileged management of namespaces.</p>
<p><a href="https://flatpak.org/">Flatpak</a>, a tool for running containerized desktop applications, allows unprivileged users to run containers by leveraging user namespaces to create the application’s sandbox. Flatpak’s runtime <a href="https://github.com/projectatomic/bubblewrap">bubblewrap</a> is also used by projects like GNOME Desktop to isolate risky processes.</p>
<p>Running containers in containers also benefits from user namespace. Docker and other runtimes heavily restrict containerized process capabilities to prevent escapes, and these restrictions prohibit running <code>docker build</code> inside a container. Project’s like Jess Frazelle’s <a href="https://github.com/genuinetools/img">img</a> get around this by using user namespaces to support <code>Dockerfile` </code>RUN` commands.</p>
<h2 id="user-namespace-security">User namespace security</h2>
<p>User namespaces are notorious for privilege escalation bugs because they expose root capabilities to unprivileged users. This can cause issues with kernel code that doesn’t account for mapped PIDs/GIDs (<a href="https://nvd.nist.gov/vuln/detail/CVE-2014-4014">CVE-2014-4014</a>, <a href="https://nvd.nist.gov/vuln/detail/CVE-2009-1338">CVE-2009-1338</a>), or allow bugs that would only be exploitable by root to be reachable by other processes (<a href="https://nvd.nist.gov/vuln/detail/CVE-2018-18955">CVE-2018-18955</a>, <a href="https://nvd.nist.gov/vuln/detail/CVE-2017-7184">CVE-2017-7184</a>, <a href="https://nvd.nist.gov/vuln/detail/CVE-2016-8655">CVE-2016-8655</a>). Historically, <a href="https://rhelblog.redhat.com/2014/03/31/containers/">RHEL</a> and <a href="https://lwn.net/Articles/673597/">Debian</a> have disabled user namespaces by default and require kernel parameters to use.</p>
<p><a href="https://twitter.com/jessfraz/status/1095134939161317377">Jess Frazelle noted</a> that the recent runc container escape (<a href="https://nvd.nist.gov/vuln/detail/CVE-2019-5736">CVE-2019-5736</a>) is mitigated by user namespaces. While true, <a href="https://twitter.com/lizrice/status/986652996816855045">not running root in containers</a> is equally valid and probably more realistic for most architectures.</p>
<p>Like many things in containerland, user namespaces don’t make isolation perfect. The hope is that allowing regular processes to use namespaces for sandboxing outweighs the increased attack surface.</p>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

